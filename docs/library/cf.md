## 一、基本介绍

---

  `cf`库是框架暴露给开发者自行使用的异步库.


## 二、方法介绍


### 1. 定时器

---

  函数原型: `cf.timeout(timeout, callback)`

  参数`timeout`为超时时间(秒), 参数`callback`为超时后触发的回调函数;

  此方法会返回一个`Timer`对象给调用者, `Timer`对象(如不需要使用可以忽略)可以用来在超时来临之前关闭定时器;

  注意: 此方法不会阻塞当前协程.

---

  函数原型: `cf.at(timeout, callback)`

  参数`timeout`为超时时间(秒), 参数`callback`为超时后触发的回调函数;

  此方法会返回一个`Timer`对象给调用者, `Timer`对象(如不需要使用可以忽略)可以用来在超时来临之前关闭定时器; 

  注意: 此方法不会阻塞当前协程. 

---

  函数原型: `cf.sleep(timeout)`

  参数`timeout`为当前协程的睡眠时间(秒); 此方法不会有返回值; 此方法的行为取决于传入的`timeout`;

  * 当`timeout > 0`的时候; 当前协程会暂停并且让出执行权, 直到超时时间来临后被唤醒;

  * 当`timeout = 0`的时候; 当前协程会暂停并且让出执行权. 没有其它协程或者其它协程任务完成后会被"立刻唤醒".

  * 当`timeout < 0`或`type(timeout) ~= number` 的时候; 此方法不会做任务动作并且直接返回.

  注意: 此方法将会阻塞当前协程直到休眠时间到达, 但是并不会阻塞进程与事件调度器.

---

  `cf.timeout`与`cf.at`的区别是: 前者只会运行一次; 后者除非主动停止, 否则会一直调用.

### 2. 协程

---

  函数原型: `cf.fork(callback)`

  参数`callback`为`function`类型, 使用此方法可以在需要的时候, 随时随地创建一个异步任务(协程). 

  与原生协程不同的是, 框架提供了完整的异步方法来管理创建的异步任务(协程)的生命周期;

  注意: 此方法会返回一个`coroutine`对象; (如不需要使用可以忽略)


---

  函数原型: `cf.self()`

  此方法用于获取当前协程对象;

  注意: 此`coroutine`对象不一定是可被框架调度的协程;

---

  函数原型: `cf.wait()`

  此方法用于暂停当前协程并且让出执行权; 此方法没有参数, 返回值的内容与类型由`cf.wakeup`决定.

---

  函数原型: `cf.wakeup(coroutine, ...)`

  此方法用于唤醒`cf.wait`暂停的协程; 调用者可根据实际情况决定是否需要传递参数;

  此方法没有返回值; 除`coroutine`对象之外的所有参数，将会返回给`cf.wait`进行接收.

---


## 三、注意

  * 协程由框架启动、回收, 可以被用户主动调用相关方法来控制具体的执行行为;

  * 协程在生命周期完成之前(返回), 不能在被直接销毁; 所以如果任务已完成请直接使用`return`结束执行流即可.

  * 协程之间不会传播异常, 所以它们之间如无关联是不会互相干扰的.

  * 一个协程出现死循环都会影响当前进程, 所以请不要进行阻塞调用影响事件循环与调度器.


